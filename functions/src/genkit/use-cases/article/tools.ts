import {defineTool} from "@genkit-ai/ai";
import * as z from "zod";

export const ToolGetAritlcesInputSchema = z
  .array(z.string().describe("The ID of the article to fetch"))
  .optional()
  .default([]);

export const ToolGetAritlcesOutputSchema = z.array(
  z.object({
    title: z.string().describe("The title of the fetched article"),
    content: z.string().describe("The content of the fetched article in plain text format"),
  }),
);

export type ToolGetAritlcesInputSchemaType = z.infer<typeof ToolGetAritlcesInputSchema>;
export type ToolGetAritlcesOutputSchemaType = z.infer<typeof ToolGetAritlcesOutputSchema>;

export const getArticlesTool = defineTool(
  {
    name: "getArticles",
    description: "A tool to fetch sample articles for style of writing analysis",
    inputSchema: ToolGetAritlcesInputSchema,
    outputSchema: ToolGetAritlcesOutputSchema,
  },
  getArticles,
);

export function getArticles(input: ToolGetAritlcesInputSchemaType = []) {
  console.log("Fetching articles with input:", input);
  return Promise.resolve(articles);
}

const articles: ToolGetAritlcesOutputSchemaType = [
  {
    title: "How to Keep Your Custom Claims in Sync with Roles Stored in Firestore",
    content: `<p data-placeholder="" class="is-empty"><br class="ProseMirror-trailingBreak"></p><p>A common <a target="_blank" rel="noopener noreferrer nofollow" class="link" href="https://stackoverflow.com/a/54394317/7967164">question I often encounter</a>, is how to maintain consistency between custom claims in Firebase Auth and role assignments stored in Firestore.</p><p>It is common in applications to have role-based authentication, where the access to resources is determined by a given role and where there are admin users have the authority to assign or revoke roles.</p><p>While Firestore provides an excellent backend to manage such information, it’s crucial that this role data also be useful in authorization logic. In Firebase this is by best practice implemented in <a target="_blank" rel="noopener noreferrer nofollow" class="link" href="https://firebase.google.com/docs/firestore/security/get-started">Firestore rules</a> and <a target="_blank" rel="noopener noreferrer nofollow" class="link" href="https://firebase.google.com/docs/storage/security/get-started">Storage rules</a> to declare resource access for database and files.</p><p>One of the ways to implement this is to only keep the data in Firestore, and another way to do it is to maintain the information in <a target="_blank" rel="noopener noreferrer nofollow" class="link" href="https://firebase.google.com/docs/auth/admin/custom-claims">auth custom claims</a>.</p><p>Both solutions has a few considerations to keep in mind.</p><h2 id="24586690-1fd6-451f-880d-4180263963e0" data-toc-id="24586690-1fd6-451f-880d-4180263963e0"><strong>Considering Your Options</strong></h2><p>As an illustration of the considerations, consider these security rules that are implementing each solution for two separate areas of the database and storage.</p><h3 id="4ddc59ac-f33c-4807-bb9e-f1dc05b96478" data-toc-id="4ddc59ac-f33c-4807-bb9e-f1dc05b96478">firestore.rules</h3><pre><code>service cloud.<span class="hljs-property">firestore</span> { match /databases/{database}/documents { <span class="hljs-comment">// Alt A: Using roles stored in Firestore user documents to determine access</span> match /collection-a/{<span class="hljs-variable language_">document</span>} { allow <span class="hljs-attr">read</span>: <span class="hljs-keyword">if</span> <span class="hljs-string">'admin'</span> <span class="hljs-keyword">in</span> <span class="hljs-title function_">getUserRoles</span>(); } <span class="hljs-comment">// Alt B: Using auth claims (role as an array) to determine access</span> match /collection-b/{<span class="hljs-variable language_">document</span>} { allow <span class="hljs-attr">read</span>: <span class="hljs-keyword">if</span> request.<span class="hljs-property">auth</span> != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-string">'admin'</span> <span class="hljs-keyword">in</span> request.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span>.<span class="hljs-property">roles</span>; } <span class="hljs-comment">// Function to get user roles from Firestore document</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserRoles</span>() { <span class="hljs-keyword">return</span> <span class="hljs-title function_">get</span>(<span class="hljs-regexp">/databases/</span>$(database)/documents/users/$(request.<span class="hljs-property">auth</span>.<span class="hljs-property">uid</span>)).<span class="hljs-property">data</span>.<span class="hljs-property">roles</span>; } } }</code></pre><h3 id="87cd379e-1f89-49f0-9dca-2a2647eb3ad5" data-toc-id="87cd379e-1f89-49f0-9dca-2a2647eb3ad5">storage.rules</h3><pre><code>service firebase.<span class="hljs-property">storage</span> { match /b/{bucket}/o { <span class="hljs-comment">// Alt A: Using roles in user documents to determine access</span> match /folder-a/{allPaths=**} { allow <span class="hljs-attr">read</span>: <span class="hljs-keyword">if</span> <span class="hljs-string">'admin'</span> <span class="hljs-keyword">in</span> <span class="hljs-title function_">getUserRoles</span>(); } <span class="hljs-comment">// Alt B: Using auth claims to determine access</span> match /folder-b/{allPaths=**} { allow <span class="hljs-attr">read</span>: <span class="hljs-keyword">if</span> request.<span class="hljs-property">auth</span> != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-string">'admin'</span> <span class="hljs-keyword">in</span> request.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span>.<span class="hljs-property">roles</span>; } <span class="hljs-comment">// Function to get user role from Firestore document</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRoleFromFirestore</span>() { <span class="hljs-keyword">return</span> <span class="hljs-title function_">get</span>(<span class="hljs-regexp">/databases/</span>$(database)/documents/users/$(request.<span class="hljs-property">auth</span>.<span class="hljs-property">uid</span>)).<span class="hljs-property">data</span>.<span class="hljs-property">role</span>; } } }</code></pre><h2 id="d019f9f7-a00a-4d46-9a88-76851324da2b" data-toc-id="d019f9f7-a00a-4d46-9a88-76851324da2b"><strong>Option A: Firestore Document Lookups</strong></h2><p>If you choose to use Firestore document lookups for role-based access control, you’re leveraging a straightforward method that works well with Firestore and Cloud Storage.</p><p>The primary drawback of this approach is its applicability is limited to just Firestore and Cloud Storage; it doesn’t extend to Firebase’s Realtime Database or other services that might benefit from integrated role-based access control.</p><p>It is also important to note that using Firestore documents to check authorization rules in both Firestore and Cloud Storage incurs additional document read costs each time an access check is performed.</p><h2 id="a9d2e08d-ea17-49d4-8844-fddb822dff44" data-toc-id="a9d2e08d-ea17-49d4-8844-fddb822dff44"><strong>Option B: Using Firebase Auth Custom Claims</strong></h2><p>The alternative involves replicating role information in Firebase Auth custom claims. This method offers broader integration across various services, including the Realtime Database and external API integrations where authentication data might be accessed via OAuth.</p><p>To implement this, a dedicated cloud function is essential for synchronizing role updates from Firestore documents to Firebase Auth custom claims. This function ensures that any changes in user roles within Firestore are promptly reflected in Firebase Auth.</p><h2 id="88cdf6e1-3e49-4c42-a40e-45cbd73d74be" data-toc-id="88cdf6e1-3e49-4c42-a40e-45cbd73d74be"><strong>Implementing the Cloud Function</strong></h2><p>The cloud function required for this task should:</p><ul><li><p>Trigger on updates to the user document specifically related to role changes.</p></li><li><p>Update Firebase Auth custom claims to reflect these changes.</p></li><li><p>Maintain any other existing custom claims in the user’s auth object.</p></li></ul><p>Here’s a simple example of such a cloud function:</p><pre><code>export const <span class="hljs-attr">updateUserRoles</span> = functions.firestore .document('/users/{userId}') .onUpdate(async (change, context) =&gt; { const <span class="hljs-attr">beforeData</span> = change.before.data()<span class="hljs-comment">;</span> const <span class="hljs-attr">afterData</span> = change.after.data()<span class="hljs-comment">;</span> // Check if roles have changed if (JSON.stringify(beforeData.roles) === JSON.stringify(afterData.roles)) { functions.logger.info('Roles are unchanged. Do nothing.')<span class="hljs-comment">;</span> return null<span class="hljs-comment">;</span> } const <span class="hljs-attr">uid</span> = context.params.userId<span class="hljs-comment">;</span> const <span class="hljs-attr">newRoles</span> = afterData.roles<span class="hljs-comment">;</span> // Get the current auth user and merge the new roles into the claims const <span class="hljs-attr">user</span> = await admin.auth().getUser(uid)<span class="hljs-comment">;</span> const <span class="hljs-attr">newClaims</span> = { ...user.customClaims, roles: newRoles }<span class="hljs-comment">;</span> return admin.auth().setCustomUserClaims(uid, newClaims)<span class="hljs-comment">;</span> })<span class="hljs-comment">;</span></code></pre><h2 id="17569af6-e346-4194-99f6-3ab32afb3d64" data-toc-id="17569af6-e346-4194-99f6-3ab32afb3d64"><strong>Conclusion</strong></h2><p>Both approaches offer distinct advantages depending on your application’s specific needs. Whether you prioritize broader service integration or a more focused, cost-effective solution within Firestore and Cloud Storage, understanding these options will empower you to make informed decisions about implementing role-based access control in your Firebase environment.</p><p data-placeholder="" class="is-empty"><br class="ProseMirror-trailingBreak"></p>`,
  },
];
